// Code generated by ogen, DO NOT EDIT.

package vault

import (
	"fmt"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"

	"github.com/ogen-go/ogen/validate"

	std "encoding/json"
	"testing"

	"github.com/stretchr/testify/require"
)

func TestAlias_EncodeDecode(t *testing.T) {
	var typ Alias
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Alias
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAliasFormat_EncodeDecode(t *testing.T) {
	var typ AliasFormat
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AliasFormat
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestAliasFormat_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "\"UUID\""},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ AliasFormat

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				var validateErr *validate.Error
				if errors.As(err, &validateErr) {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 AliasFormat
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestApiError_EncodeDecode(t *testing.T) {
	var typ ApiError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ApiError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestApiErrorsResponse_EncodeDecode(t *testing.T) {
	var typ ApiErrorsResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ApiErrorsResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateAliasesCreated_EncodeDecode(t *testing.T) {
	var typ CreateAliasesCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateAliasesCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateAliasesRequest_EncodeDecode(t *testing.T) {
	var typ CreateAliasesRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateAliasesRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestCreateAliasesRequest_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"data\":[{\"alias\":\"tok_sandbox_bhtsCwFUzoJMw9rWUfEV5e\",\"format\":\"RAW_UUID\",\"storage\":\"PERSISTENT\"}]}"},
		{Input: "{\"data\":[{\"classifiers\":[\"bank-account\"],\"format\":\"UUID\",\"storage\":\"PERSISTENT\",\"value\":122105155}]}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ CreateAliasesRequest

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				var validateErr *validate.Error
				if errors.As(err, &validateErr) {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 CreateAliasesRequest
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestCreateAliasesRequestDataItem_EncodeDecode(t *testing.T) {
	var typ CreateAliasesRequestDataItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateAliasesRequestDataItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateAliasesRequestDataItem0_EncodeDecode(t *testing.T) {
	var typ CreateAliasesRequestDataItem0
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateAliasesRequestDataItem0
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateAliasesRequestDataItem0Storage_EncodeDecode(t *testing.T) {
	var typ CreateAliasesRequestDataItem0Storage
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateAliasesRequestDataItem0Storage
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateAliasesRequestDataItem1_EncodeDecode(t *testing.T) {
	var typ CreateAliasesRequestDataItem1
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateAliasesRequestDataItem1
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRevealMultipleAliasesOK_EncodeDecode(t *testing.T) {
	var typ RevealMultipleAliasesOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RevealMultipleAliasesOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestRevealMultipleAliasesOK_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"tok_sandbox_5UpnbMvaihRuRwz5QXwBFw\":{\"aliases\":[{\"format\":\"UUID\",\"value\":\"tok_sandbox_5UpnbMvaihRuRwz5QXwBFw\"}],\"classifiers\":[\"bank-account\"],\"created_at\":\"2019-08-10T11:45:30Z\",\"storage\":\"VOLATILE\",\"value\":\"476673481\"},\"tok_sandbox_9ToiJHedw1nE1Jfx1qYYgz\":{\"aliases\":[{\"format\":\"UUID\",\"value\":\"tok_sandbox_9ToiJHedw1nE1Jfx1qYYgz\"}],\"classifiers\":[\"bank-account\"],\"created_at\":\"2019-08-10T11:45:30Z\",\"storage\":\"VOLATILE\",\"value\":\"750360025\"}}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ RevealMultipleAliasesOK

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				var validateErr *validate.Error
				if errors.As(err, &validateErr) {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 RevealMultipleAliasesOK
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestRevealedData_EncodeDecode(t *testing.T) {
	var typ RevealedData
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RevealedData
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRevealedDataStorage_EncodeDecode(t *testing.T) {
	var typ RevealedDataStorage
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RevealedDataStorage
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateAliasRequest_EncodeDecode(t *testing.T) {
	var typ UpdateAliasRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateAliasRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateAliasRequestData_EncodeDecode(t *testing.T) {
	var typ UpdateAliasRequestData
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateAliasRequestData
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
