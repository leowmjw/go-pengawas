// Code generated by ogen, DO NOT EDIT.

package payments

import (
	"context"
	"io"
	"net/url"
	"time"

	"github.com/go-faster/errors"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/metric/instrument/syncint64"
	"go.opentelemetry.io/otel/trace"

	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/otelogen"
	"github.com/ogen-go/ogen/uri"
)

// Client implements OAS client.
type Client struct {
	serverURL *url.URL
	cfg       config
	requests  syncint64.Counter
	errors    syncint64.Counter
	duration  syncint64.Histogram
}

// NewClient initializes new Client defined by OAS.
func NewClient(serverURL string, opts ...Option) (*Client, error) {
	u, err := url.Parse(serverURL)
	if err != nil {
		return nil, err
	}
	c := &Client{
		cfg:       newConfig(opts...),
		serverURL: u,
	}
	if c.requests, err = c.cfg.Meter.SyncInt64().Counter(otelogen.ClientRequestCount); err != nil {
		return nil, err
	}
	if c.errors, err = c.cfg.Meter.SyncInt64().Counter(otelogen.ClientErrorsCount); err != nil {
		return nil, err
	}
	if c.duration, err = c.cfg.Meter.SyncInt64().Histogram(otelogen.ClientDuration); err != nil {
		return nil, err
	}
	return c, nil
}

// CreateFinancialInstrument invokes CreateFinancialInstrument operation.
//
// Create a financial instrument for later use for sending or receiving money.
//
// POST /financial_instruments
func (c *Client) CreateFinancialInstrument(ctx context.Context, request OptPaymentCardCreate) (res CreateFinancialInstrumentRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("CreateFinancialInstrument"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "CreateFinancialInstrument",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     func() (io.ReadCloser, error)
	)
	contentType = "application/json"
	fn, err := encodeCreateFinancialInstrumentRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	reqBody = fn

	u := uri.Clone(c.serverURL)
	u.Path += "/financial_instruments"

	body, err := reqBody()
	if err != nil {
		return res, errors.Wrap(err, "request body")
	}
	defer body.Close()

	r := ht.NewRequest(ctx, "POST", u, body)
	defer ht.PutRequest(r)
	r.GetBody = reqBody

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateFinancialInstrumentResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateGateway invokes CreateGateway operation.
//
// Create a gateway with PSP's credentials to point transfers to based on certain criteria.
//
// POST /gateways
func (c *Client) CreateGateway(ctx context.Context, request OptGatewayCreate) (res CreateGatewayRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("CreateGateway"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "CreateGateway",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     func() (io.ReadCloser, error)
	)
	contentType = "application/json"
	fn, err := encodeCreateGatewayRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	reqBody = fn

	u := uri.Clone(c.serverURL)
	u.Path += "/gateways"

	body, err := reqBody()
	if err != nil {
		return res, errors.Wrap(err, "request body")
	}
	defer body.Close()

	r := ht.NewRequest(ctx, "POST", u, body)
	defer ht.PutRequest(r)
	r.GetBody = reqBody

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateGatewayResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateOrder invokes CreateOrder operation.
//
// Place an order and return session id for it.
//
// POST /orders
func (c *Client) CreateOrder(ctx context.Context, request OptOrderCreate) (res CreateOrderRes, err error) {
	if err := func() error {
		if request.Set {
			if err := func() error {
				if err := request.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("CreateOrder"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "CreateOrder",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     func() (io.ReadCloser, error)
	)
	contentType = "application/json"
	fn, err := encodeCreateOrderRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	reqBody = fn

	u := uri.Clone(c.serverURL)
	u.Path += "/orders"

	body, err := reqBody()
	if err != nil {
		return res, errors.Wrap(err, "request body")
	}
	defer body.Close()

	r := ht.NewRequest(ctx, "POST", u, body)
	defer ht.PutRequest(r)
	r.GetBody = reqBody

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateOrderResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateRule invokes CreateRule operation.
//
// Create a rule by which the API will determine to which gateway to point the transfers to based on
// whether the rule conditions are met.
//
// POST /rules
func (c *Client) CreateRule(ctx context.Context, request OptRuleCreate) (res CreateRuleRes, err error) {
	if err := func() error {
		if request.Set {
			if err := func() error {
				if err := request.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("CreateRule"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "CreateRule",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     func() (io.ReadCloser, error)
	)
	contentType = "application/json"
	fn, err := encodeCreateRuleRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	reqBody = fn

	u := uri.Clone(c.serverURL)
	u.Path += "/rules"

	body, err := reqBody()
	if err != nil {
		return res, errors.Wrap(err, "request body")
	}
	defer body.Close()

	r := ht.NewRequest(ctx, "POST", u, body)
	defer ht.PutRequest(r)
	r.GetBody = reqBody

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateRuleResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateThreeDSAuthentication invokes CreateThreeDSAuthentication operation.
//
// Create a 3DS authentication.
// Mainly to be invoked by VGS checkout.js, not meant to be called by user directly.
//
// POST /3ds_authentications
func (c *Client) CreateThreeDSAuthentication(ctx context.Context, request OptThreeDSAuthenticationCreate) (res CreateThreeDSAuthenticationRes, err error) {
	if err := func() error {
		if request.Set {
			if err := func() error {
				if err := request.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("CreateThreeDSAuthentication"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "CreateThreeDSAuthentication",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     func() (io.ReadCloser, error)
	)
	contentType = "application/json"
	fn, err := encodeCreateThreeDSAuthenticationRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	reqBody = fn

	u := uri.Clone(c.serverURL)
	u.Path += "/3ds_authentications"

	body, err := reqBody()
	if err != nil {
		return res, errors.Wrap(err, "request body")
	}
	defer body.Close()

	r := ht.NewRequest(ctx, "POST", u, body)
	defer ht.PutRequest(r)
	r.GetBody = reqBody

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateThreeDSAuthenticationResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateThreeDSProvider invokes CreateThreeDSProvider operation.
//
// Create a 3DS provider with the credentials and configuration.
// Currently only one 3DS provider creation is allowed. Please contact VGS support if you need to
// replace the old 3DS provider.
//
// POST /3ds_providers
func (c *Client) CreateThreeDSProvider(ctx context.Context, request OptThreeDSProviderCreate) (res CreateThreeDSProviderRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("CreateThreeDSProvider"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "CreateThreeDSProvider",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     func() (io.ReadCloser, error)
	)
	contentType = "application/json"
	fn, err := encodeCreateThreeDSProviderRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	reqBody = fn

	u := uri.Clone(c.serverURL)
	u.Path += "/3ds_providers"

	body, err := reqBody()
	if err != nil {
		return res, errors.Wrap(err, "request body")
	}
	defer body.Close()

	r := ht.NewRequest(ctx, "POST", u, body)
	defer ht.PutRequest(r)
	r.GetBody = reqBody

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateThreeDSProviderResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateTransfer invokes CreateTransfer operation.
//
// Creates a transfer record in one of the ways:
// 1. Capture the funds instantly
// 2. Create an authorization to be captured manually later.
// The authorization places the funds on hold with the customer's bank. This can be useful in
// situations where you need to make a sale, but won't be able to ship merchandise for several days.
// You can authorize the transfer to ensure funds availability, then capture the transfer to obtain
// the funds upon shipment.
// 3. Creates a transfer from order information.
//
// POST /transfers
func (c *Client) CreateTransfer(ctx context.Context, request *TransferCreate) (res CreateTransferRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("CreateTransfer"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "CreateTransfer",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     func() (io.ReadCloser, error)
	)
	contentType = "application/json"
	fn, err := encodeCreateTransferRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	reqBody = fn

	u := uri.Clone(c.serverURL)
	u.Path += "/transfers"

	body, err := reqBody()
	if err != nil {
		return res, errors.Wrap(err, "request body")
	}
	defer body.Close()

	r := ht.NewRequest(ctx, "POST", u, body)
	defer ht.PutRequest(r)
	r.GetBody = reqBody

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateTransferResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateVerification invokes CreateVerification operation.
//
// This request verifies that the customer's card is valid without actually charging an amount on the
// card. For example, you may want to verify a credit card before adding it to a customer profile for
// future billing transfers.
// The exact verification method varies from psp to psp, but usually this is either a $0 charge, or a
// $1 authorization with immediate cancellation.
//
// POST /verifications
func (c *Client) CreateVerification(ctx context.Context, request *Verification) (res CreateVerificationRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("CreateVerification"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "CreateVerification",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     func() (io.ReadCloser, error)
	)
	contentType = "application/json"
	fn, err := encodeCreateVerificationRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	reqBody = fn

	u := uri.Clone(c.serverURL)
	u.Path += "/verifications"

	body, err := reqBody()
	if err != nil {
		return res, errors.Wrap(err, "request body")
	}
	defer body.Close()

	r := ht.NewRequest(ctx, "POST", u, body)
	defer ht.PutRequest(r)
	r.GetBody = reqBody

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateVerificationResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteFinancialInstrumentById invokes DeleteFinancialInstrumentById operation.
//
// Delete a particular financial instrument by id.
//
// DELETE /financial_instruments/{financial_instrument_id}
func (c *Client) DeleteFinancialInstrumentById(ctx context.Context, params DeleteFinancialInstrumentByIdParams) (res DeleteFinancialInstrumentByIdRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("DeleteFinancialInstrumentById"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "DeleteFinancialInstrumentById",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/financial_instruments/"
	{
		// Encode "financial_instrument_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "financial_instrument_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.FinancialInstrumentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteFinancialInstrumentByIdResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteGateway invokes DeleteGateway operation.
//
// DELETE /gateways/{gateway_id}
func (c *Client) DeleteGateway(ctx context.Context, params DeleteGatewayParams) (res DeleteGatewayRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("DeleteGateway"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "DeleteGateway",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/gateways/"
	{
		// Encode "gateway_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "gateway_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GatewayID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteGatewayResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteRule invokes DeleteRule operation.
//
// DELETE /rules/{rule_id}
func (c *Client) DeleteRule(ctx context.Context, params DeleteRuleParams) (res DeleteRuleRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("DeleteRule"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "DeleteRule",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/rules/"
	{
		// Encode "rule_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "rule_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RuleID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "DELETE", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteRuleResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// FinalizeTransfer invokes FinalizeTransfer operation.
//
// Finalize the transfer by moving its state from `pending` to `successful` (captured) or `canceled`
// via the `action` parameter.
// Only transfers with `debit` type and `pending` state is allowed.
// When `capture` is passed in the `action` parameter, the funds, previously held with the customer's
// bank,
// will be transferred from the customer to the gateway's account owner or merchant.
// It will also update the transfer's `state` from `pending` to `successful` if the capture is
// successful and
// return the same transfer with `200` status. The `amount_captured` will be updated accordingly.
// When `cancel` is passed in the `action` parameter, the funds, previously held with the customer's
// bank,
// will be released. Some cards may not support a hard release and the funds will be made available
// after
// a period of seven days from the original authorization.
// It will create a new transfer with `reversal` type, return it with `201` status.
// The `amount_reversed` of original transfer will be updated accordingly.
//
// PUT /transfers/{transfer_id}
func (c *Client) FinalizeTransfer(ctx context.Context, request OptTransferUpdate, params FinalizeTransferParams) (res FinalizeTransferRes, err error) {
	if err := func() error {
		if request.Set {
			if err := func() error {
				if err := request.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("FinalizeTransfer"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "FinalizeTransfer",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     func() (io.ReadCloser, error)
	)
	contentType = "application/json"
	fn, err := encodeFinalizeTransferRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	reqBody = fn

	u := uri.Clone(c.serverURL)
	u.Path += "/transfers/"
	{
		// Encode "transfer_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "transfer_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TransferID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	body, err := reqBody()
	if err != nil {
		return res, errors.Wrap(err, "request body")
	}
	defer body.Close()

	r := ht.NewRequest(ctx, "PUT", u, body)
	defer ht.PutRequest(r)
	r.GetBody = reqBody

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeFinalizeTransferResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetFinancialInstrumentById invokes GetFinancialInstrumentById operation.
//
// Get a particular financial instrument by id.
//
// GET /financial_instruments/{financial_instrument_id}
func (c *Client) GetFinancialInstrumentById(ctx context.Context, params GetFinancialInstrumentByIdParams) (res GetFinancialInstrumentByIdRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("GetFinancialInstrumentById"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "GetFinancialInstrumentById",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/financial_instruments/"
	{
		// Encode "financial_instrument_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "financial_instrument_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.FinancialInstrumentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetFinancialInstrumentByIdResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetFinancialInstruments invokes GetFinancialInstruments operation.
//
// List financial instrument records filtered by the query condition if provided.
//
// GET /financial_instruments
func (c *Client) GetFinancialInstruments(ctx context.Context, params GetFinancialInstrumentsParams) (res GetFinancialInstrumentsRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("GetFinancialInstruments"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "GetFinancialInstruments",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/financial_instruments"
	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetFinancialInstrumentsResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetGatewayById invokes GetGatewayById operation.
//
// Get a particular gateway by id.
//
// GET /gateways/{gateway_id}
func (c *Client) GetGatewayById(ctx context.Context, params GetGatewayByIdParams) (res GetGatewayByIdRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("GetGatewayById"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "GetGatewayById",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/gateways/"
	{
		// Encode "gateway_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "gateway_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GatewayID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetGatewayByIdResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetGateways invokes GetGateways operation.
//
// List gateway records filtered by the query condition if provided.
//
// GET /gateways
func (c *Client) GetGateways(ctx context.Context, params GetGatewaysParams) (res GetGatewaysRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("GetGateways"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "GetGateways",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/gateways"
	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetGatewaysResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetRuleById invokes GetRuleById operation.
//
// Get a particular rule by id.
//
// GET /rules/{rule_id}
func (c *Client) GetRuleById(ctx context.Context, params GetRuleByIdParams) (res GetRuleByIdRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("GetRuleById"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "GetRuleById",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/rules/"
	{
		// Encode "rule_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "rule_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RuleID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetRuleByIdResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetRules invokes GetRules operation.
//
// List rule records filtered by the query condition if provided.
//
// GET /rules
func (c *Client) GetRules(ctx context.Context, params GetRulesParams) (res GetRulesRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("GetRules"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "GetRules",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/rules"
	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetRulesResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetTransferById invokes GetTransferById operation.
//
// Get a particular transfer by id.
//
// GET /transfers/{transfer_id}
func (c *Client) GetTransferById(ctx context.Context, params GetTransferByIdParams) (res GetTransferByIdRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("GetTransferById"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "GetTransferById",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/transfers/"
	{
		// Encode "transfer_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "transfer_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TransferID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetTransferByIdResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetTransfers invokes GetTransfers operation.
//
// List transfer records filtered by the query condition if provided.
//
// GET /transfers
func (c *Client) GetTransfers(ctx context.Context, params GetTransfersParams) (res GetTransfersRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("GetTransfers"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "GetTransfers",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/transfers"
	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetTransfersResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrdersOrderIDGet invokes  operation.
//
// Get a particular order by id.
//
// GET /orders/{order_id}
func (c *Client) OrdersOrderIDGet(ctx context.Context, params OrdersOrderIDGetParams) (res OrdersOrderIDGetRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{}
	ctx, span := c.cfg.Tracer.Start(ctx, "OrdersOrderIDGet",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	u := uri.Clone(c.serverURL)
	u.Path += "/orders/"
	{
		// Encode "order_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "order_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OrderID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	r := ht.NewRequest(ctx, "GET", u, nil)
	defer ht.PutRequest(r)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeOrdersOrderIDGetResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReverseTransferById invokes ReverseTransferById operation.
//
// Reverse a specific transfer by id.
//
// POST /transfers/{transfer_id}/reversals
func (c *Client) ReverseTransferById(ctx context.Context, request OptReversal, params ReverseTransferByIdParams) (res ReverseTransferByIdRes, err error) {
	if err := func() error {
		if request.Set {
			if err := func() error {
				if err := request.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("ReverseTransferById"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ReverseTransferById",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     func() (io.ReadCloser, error)
	)
	contentType = "application/json"
	fn, err := encodeReverseTransferByIdRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	reqBody = fn

	u := uri.Clone(c.serverURL)
	u.Path += "/transfers/"
	{
		// Encode "transfer_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "transfer_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TransferID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/reversals"

	body, err := reqBody()
	if err != nil {
		return res, errors.Wrap(err, "request body")
	}
	defer body.Close()

	r := ht.NewRequest(ctx, "POST", u, body)
	defer ht.PutRequest(r)
	r.GetBody = reqBody

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReverseTransferByIdResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ThreeDSAuthenticationChallenge invokes ThreeDSAuthenticationChallenge operation.
//
// Finish the challenge step for the 3DS authentication session.
// Mainly to be invoked by VGS checkout.js, not meant to be called by user directly.
//
// POST /3ds_authentications/{3ds_authentication_id}/challenges
func (c *Client) ThreeDSAuthenticationChallenge(ctx context.Context, request *ThreeDSAuthenticationChallengeReq, params ThreeDSAuthenticationChallengeParams) (res ThreeDSAuthenticationChallengeRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("ThreeDSAuthenticationChallenge"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ThreeDSAuthenticationChallenge",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     func() (io.ReadCloser, error)
	)
	contentType = "application/json"
	fn, err := encodeThreeDSAuthenticationChallengeRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	reqBody = fn

	u := uri.Clone(c.serverURL)
	u.Path += "/3ds_authentications/"
	{
		// Encode "3ds_authentication_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "3ds_authentication_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.R3dsAuthenticationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/challenges"

	body, err := reqBody()
	if err != nil {
		return res, errors.Wrap(err, "request body")
	}
	defer body.Close()

	r := ht.NewRequest(ctx, "POST", u, body)
	defer ht.PutRequest(r)
	r.GetBody = reqBody

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeThreeDSAuthenticationChallengeResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ThreeDSAuthenticationDeviceFingerprint invokes ThreeDSAuthenticationDeviceFingerprint operation.
//
// Finish the device fingerprint step for the 3DS authentication session.
// Mainly to be invoked by VGS checkout.js, not meant to be called by user directly.
//
// POST /3ds_authentications/{3ds_authentication_id}/fingerprints
func (c *Client) ThreeDSAuthenticationDeviceFingerprint(ctx context.Context, request *ThreeDSAuthenticationDeviceFingerprintReq, params ThreeDSAuthenticationDeviceFingerprintParams) (res ThreeDSAuthenticationDeviceFingerprintRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("ThreeDSAuthenticationDeviceFingerprint"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "ThreeDSAuthenticationDeviceFingerprint",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     func() (io.ReadCloser, error)
	)
	contentType = "application/json"
	fn, err := encodeThreeDSAuthenticationDeviceFingerprintRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	reqBody = fn

	u := uri.Clone(c.serverURL)
	u.Path += "/3ds_authentications/"
	{
		// Encode "3ds_authentication_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "3ds_authentication_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.R3dsAuthenticationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}
	u.Path += "/fingerprints"

	body, err := reqBody()
	if err != nil {
		return res, errors.Wrap(err, "request body")
	}
	defer body.Close()

	r := ht.NewRequest(ctx, "POST", u, body)
	defer ht.PutRequest(r)
	r.GetBody = reqBody

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeThreeDSAuthenticationDeviceFingerprintResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateGatewayById invokes UpdateGatewayById operation.
//
// Update a particular gateway by id.
//
// PUT /gateways/{gateway_id}
func (c *Client) UpdateGatewayById(ctx context.Context, request OptGatewayUpdate, params UpdateGatewayByIdParams) (res UpdateGatewayByIdRes, err error) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("UpdateGatewayById"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "UpdateGatewayById",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     func() (io.ReadCloser, error)
	)
	contentType = "application/json"
	fn, err := encodeUpdateGatewayByIdRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	reqBody = fn

	u := uri.Clone(c.serverURL)
	u.Path += "/gateways/"
	{
		// Encode "gateway_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "gateway_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GatewayID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	body, err := reqBody()
	if err != nil {
		return res, errors.Wrap(err, "request body")
	}
	defer body.Close()

	r := ht.NewRequest(ctx, "PUT", u, body)
	defer ht.PutRequest(r)
	r.GetBody = reqBody

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateGatewayByIdResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateRuleById invokes UpdateRuleById operation.
//
// Update a particular rule by id.
//
// PUT /rules/{rule_id}
func (c *Client) UpdateRuleById(ctx context.Context, request OptRuleUpdate, params UpdateRuleByIdParams) (res UpdateRuleByIdRes, err error) {
	if err := func() error {
		if request.Set {
			if err := func() error {
				if err := request.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("UpdateRuleById"),
	}
	ctx, span := c.cfg.Tracer.Start(ctx, "UpdateRuleById",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer func() {
		if err != nil {
			span.RecordError(err)
			c.errors.Add(ctx, 1, otelAttrs...)
		} else {
			elapsedDuration := time.Since(startTime)
			c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
		}
		span.End()
	}()
	c.requests.Add(ctx, 1, otelAttrs...)
	var (
		contentType string
		reqBody     func() (io.ReadCloser, error)
	)
	contentType = "application/json"
	fn, err := encodeUpdateRuleByIdRequestJSON(request, span)
	if err != nil {
		return res, err
	}
	reqBody = fn

	u := uri.Clone(c.serverURL)
	u.Path += "/rules/"
	{
		// Encode "rule_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "rule_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RuleID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		u.Path += e.Result()
	}

	body, err := reqBody()
	if err != nil {
		return res, errors.Wrap(err, "request body")
	}
	defer body.Close()

	r := ht.NewRequest(ctx, "PUT", u, body)
	defer ht.PutRequest(r)
	r.GetBody = reqBody

	r.Header.Set("Content-Type", contentType)

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateRuleByIdResponse(resp, span)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}
