// Code generated by ogen, DO NOT EDIT.

package payments

import (
	"fmt"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"

	"github.com/ogen-go/ogen/validate"

	std "encoding/json"
	"testing"

	"github.com/stretchr/testify/require"
)

func TestAVSResult_EncodeDecode(t *testing.T) {
	var typ AVSResult
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AVSResult
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAmount_EncodeDecode(t *testing.T) {
	var typ Amount
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Amount
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestApiError_EncodeDecode(t *testing.T) {
	var typ ApiError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ApiError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBrowserInfo_EncodeDecode(t *testing.T) {
	var typ BrowserInfo
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BrowserInfo
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFinalizeTransferApplicationJSONCreated_EncodeDecode(t *testing.T) {
	var typ FinalizeTransferApplicationJSONCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FinalizeTransferApplicationJSONCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFinalizeTransferApplicationJSONOK_EncodeDecode(t *testing.T) {
	var typ FinalizeTransferApplicationJSONOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FinalizeTransferApplicationJSONOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFinancialInstrument_EncodeDecode(t *testing.T) {
	var typ FinancialInstrument
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FinancialInstrument
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestFinancialInstrument_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"data\":{\"card\":{\"billing_address\":{\"address1\":\"555 Unblock Us St\",\"address2\":\"M13 9PL\",\"city\":\"New York\",\"company\":\"John Doe Company\",\"country\":\"US\",\"name\":\"John Doe\",\"phone\":\"+14842634673\",\"postal_code\":12301,\"region\":\"NY\"},\"cvc\":\"123\",\"exp_month\":10,\"exp_year\":2030,\"name\":\"John Doe\",\"number\":41111111111111},\"created_at\":\"2021-05-15T12:30:45Z\",\"id\":\"FN6imeVBVSrfyS62QiE2kFCv\",\"updated_at\":\"2021-05-15T12:30:45Z\"}}"},
		{Input: "{\"data\":{\"card\":{\"cvc\":\"123\",\"exp_month\":10,\"exp_year\":2030,\"name\":\"John Doe\",\"number\":41111111111111},\"created_at\":\"2021-05-15T12:30:45Z\",\"id\":\"FN6imeVBVSrfyS62QiE2kFCv\",\"updated_at\":\"2021-05-15T12:30:45Z\"}}"},
		{Input: "{\"data\":{\"created_at\":\"2021-05-15T12:30:45Z\",\"id\":\"FN6imeVBVSrfyS62QiE2kFCv\",\"psp_token\":{\"id\":\"card_asdf1234\",\"psp\":\"stripe\"},\"updated_at\":\"2021-05-15T12:30:45Z\"}}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ FinancialInstrument

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				var validateErr *validate.Error
				if errors.As(err, &validateErr) {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 FinancialInstrument
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestFinancialInstrumentApiErrors_EncodeDecode(t *testing.T) {
	var typ FinancialInstrumentApiErrors
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FinancialInstrumentApiErrors
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFinancialInstrumentError_EncodeDecode(t *testing.T) {
	var typ FinancialInstrumentError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FinancialInstrumentError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFinancialInstrumentListData_EncodeDecode(t *testing.T) {
	var typ FinancialInstrumentListData
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FinancialInstrumentListData
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFinancialInstrumentListDataLinks_EncodeDecode(t *testing.T) {
	var typ FinancialInstrumentListDataLinks
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FinancialInstrumentListDataLinks
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFinancialInstrumentListDataMeta_EncodeDecode(t *testing.T) {
	var typ FinancialInstrumentListDataMeta
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FinancialInstrumentListDataMeta
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGateway_EncodeDecode(t *testing.T) {
	var typ Gateway
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Gateway
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGatewayConfig_EncodeDecode(t *testing.T) {
	var typ GatewayConfig
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GatewayConfig
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGatewayCreate_EncodeDecode(t *testing.T) {
	var typ GatewayCreate
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GatewayCreate
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestGatewayCreate_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"config\":{\"login\":\"sk_test_foobarbaz\"},\"id\":\"stripe-test\",\"type\":\"stripe\"}"},
		{Input: "{\"config\":{\"merchant_account\":\"BARBAR\",\"password\":\"foo\",\"username\":\"username\"},\"id\":\"adyen-merchant-bar\",\"type\":\"adyen\"}"},
		{Input: "{\"config\":{\"merchant_id\":\"merchant_id\",\"private_key\":\"public_key\",\"public_key\":\"public_key\"},\"default_gateway\":true,\"id\":\"braintree-test\",\"type\":\"braintree\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ GatewayCreate

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				var validateErr *validate.Error
				if errors.As(err, &validateErr) {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 GatewayCreate
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestGatewayCreateConfig_EncodeDecode(t *testing.T) {
	var typ GatewayCreateConfig
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GatewayCreateConfig
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGatewayData_EncodeDecode(t *testing.T) {
	var typ GatewayData
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GatewayData
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGatewayListData_EncodeDecode(t *testing.T) {
	var typ GatewayListData
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GatewayListData
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGatewayListDataLinks_EncodeDecode(t *testing.T) {
	var typ GatewayListDataLinks
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GatewayListDataLinks
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGatewayListDataMeta_EncodeDecode(t *testing.T) {
	var typ GatewayListDataMeta
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GatewayListDataMeta
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGatewayOptions_EncodeDecode(t *testing.T) {
	var typ GatewayOptions
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GatewayOptions
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestGatewayOptions_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"currency\":\"USD\",\"shipping_address\":{\"address1\":\"555 Unblock Us St\",\"address2\":\"M13 9PL\",\"city\":\"New York\",\"company\":\"John Doe Company\",\"country\":\"US\",\"name\":\"John Doe\",\"phone\":\"+14842634673\",\"postal_code\":\"12301\",\"region\":\"NY\"}}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ GatewayOptions

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				var validateErr *validate.Error
				if errors.As(err, &validateErr) {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 GatewayOptions
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestGatewayOptionsAdditional_EncodeDecode(t *testing.T) {
	var typ GatewayOptionsAdditional
	typ = make(GatewayOptionsAdditional)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GatewayOptionsAdditional
	typ2 = make(GatewayOptionsAdditional)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGatewayOptionsAdditionalItem_EncodeDecode(t *testing.T) {
	var typ GatewayOptionsAdditionalItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GatewayOptionsAdditionalItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGatewayPSPType_EncodeDecode(t *testing.T) {
	var typ GatewayPSPType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GatewayPSPType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGatewayUpdate_EncodeDecode(t *testing.T) {
	var typ GatewayUpdate
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GatewayUpdate
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestGatewayUpdate_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"config\":{\"login\":\"sk_test_foobarbaz\"},\"type\":\"stripe\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ GatewayUpdate

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				var validateErr *validate.Error
				if errors.As(err, &validateErr) {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 GatewayUpdate
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestGatewayUpdateConfig_EncodeDecode(t *testing.T) {
	var typ GatewayUpdateConfig
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GatewayUpdateConfig
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGatewaysApiErrors_EncodeDecode(t *testing.T) {
	var typ GatewaysApiErrors
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GatewaysApiErrors
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGeneralError_EncodeDecode(t *testing.T) {
	var typ GeneralError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GeneralError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestOrder_EncodeDecode(t *testing.T) {
	var typ Order
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Order
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestOrderApiErrors_EncodeDecode(t *testing.T) {
	var typ OrderApiErrors
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OrderApiErrors
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestOrderCreate_EncodeDecode(t *testing.T) {
	var typ OrderCreate
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OrderCreate
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestOrderCreateItemsItem_EncodeDecode(t *testing.T) {
	var typ OrderCreateItemsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OrderCreateItemsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestOrderData_EncodeDecode(t *testing.T) {
	var typ OrderData
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OrderData
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPaymentCardCreate_EncodeDecode(t *testing.T) {
	var typ PaymentCardCreate
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PaymentCardCreate
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestPaymentCardCreate_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"card\":{\"billing_address\":{\"address1\":\"555 Unblock Us St\",\"address2\":\"M13 9PL\",\"city\":\"New York\",\"company\":\"John Doe Company\",\"country\":\"US\",\"name\":\"John Doe\",\"phone\":\"+14842634673\",\"postal_code\":12301,\"region\":\"NY\"},\"cvc\":\"123\",\"exp_month\":10,\"exp_year\":2030,\"name\":\"John Doe\",\"number\":41111111111111}}"},
		{Input: "{\"card\":{\"cvc\":\"123\",\"exp_month\":10,\"exp_year\":2030,\"name\":\"John Doe\",\"number\":41111111111111}}"},
		{Input: "{\"psp_token\":{\"id\":\"card_asdf1234\",\"psp\":\"stripe\"}}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ PaymentCardCreate

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				var validateErr *validate.Error
				if errors.As(err, &validateErr) {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 PaymentCardCreate
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestPaymentCardDetails_EncodeDecode(t *testing.T) {
	var typ PaymentCardDetails
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PaymentCardDetails
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPaymentCardDetailsCreate_EncodeDecode(t *testing.T) {
	var typ PaymentCardDetailsCreate
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PaymentCardDetailsCreate
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPaymentCardObject_EncodeDecode(t *testing.T) {
	var typ PaymentCardObject
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PaymentCardObject
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReversal_EncodeDecode(t *testing.T) {
	var typ Reversal
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Reversal
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestReversal_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"amount\":100}"},
		{Input: "{}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ Reversal

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				var validateErr *validate.Error
				if errors.As(err, &validateErr) {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 Reversal
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestRule_EncodeDecode(t *testing.T) {
	var typ Rule
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Rule
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRuleAction_EncodeDecode(t *testing.T) {
	var typ RuleAction
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RuleAction
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRuleCreate_EncodeDecode(t *testing.T) {
	var typ RuleCreate
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RuleCreate
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestRuleCreate_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"action\":\"block\",\"criteria\":\"transfer.currency == 'EUR' \\u0026\\u0026 transfer.amount \\u003e= 50000\",\"description\":\"Block high EUR transfers\",\"ordinal\":2}"},
		{Input: "{\"action\":\"retry\",\"criteria\":\"transfer.state == 'failed' \\u0026\\u0026 transfer.gateway_response.state == 'timeout'\",\"description\":\"Route EUR transfers to Adyen\",\"ordinal\":1,\"route_to_gateway\":\"adyen\"}"},
		{Input: "{\"action\":\"route\",\"criteria\":\"card.brand == 'AmericanExpress'\",\"description\":\"Route American Express to Stripe\",\"ordinal\":4,\"route_to_gateway\":\"stripe\"}"},
		{Input: "{\"action\":\"route\",\"criteria\":\"env.username == 'jess'\",\"description\":\"Route jess to their merchant account on worldpay\",\"ordinal\":3,\"route_to_gateway\":\"worldpay-jess\"}"},
		{Input: "{\"action\":\"route\",\"criteria\":\"transfer.currency == 'EUR'\",\"description\":\"Route EUR transfers to Adyen\",\"ordinal\":0,\"route_to_gateway\":\"adyen\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ RuleCreate

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				var validateErr *validate.Error
				if errors.As(err, &validateErr) {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 RuleCreate
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestRuleCreateAction_EncodeDecode(t *testing.T) {
	var typ RuleCreateAction
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RuleCreateAction
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRuleData_EncodeDecode(t *testing.T) {
	var typ RuleData
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RuleData
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRuleListData_EncodeDecode(t *testing.T) {
	var typ RuleListData
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RuleListData
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRuleListDataLinks_EncodeDecode(t *testing.T) {
	var typ RuleListDataLinks
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RuleListDataLinks
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRuleListDataMeta_EncodeDecode(t *testing.T) {
	var typ RuleListDataMeta
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RuleListDataMeta
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRuleUpdate_EncodeDecode(t *testing.T) {
	var typ RuleUpdate
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RuleUpdate
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestRuleUpdate_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"criteria\":\"transfer.currency == 'EUR'\",\"description\":\"Block high EUR transfers\",\"ordinal\":3}"},
		{Input: "{\"criteria\":\"transfer.currency == 'EUR'\"}"},
		{Input: "{\"description\":\"Block high EUR transfers\"}"},
		{Input: "{\"ordinal\":3}"},
		{Input: "{\"route_to_gateway\":\"adyen\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ RuleUpdate

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				var validateErr *validate.Error
				if errors.As(err, &validateErr) {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 RuleUpdate
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestRuleUpdateAction_EncodeDecode(t *testing.T) {
	var typ RuleUpdateAction
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RuleUpdateAction
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRulesApiErrors_EncodeDecode(t *testing.T) {
	var typ RulesApiErrors
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RulesApiErrors
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestStoredFinancialInstrument_EncodeDecode(t *testing.T) {
	var typ StoredFinancialInstrument
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 StoredFinancialInstrument
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestThreeDSAuthentication_EncodeDecode(t *testing.T) {
	var typ ThreeDSAuthentication
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ThreeDSAuthentication
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestThreeDSAuthenticationChallenge_EncodeDecode(t *testing.T) {
	var typ ThreeDSAuthenticationChallenge
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ThreeDSAuthenticationChallenge
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestThreeDSAuthenticationChallengeParams_EncodeDecode(t *testing.T) {
	var typ ThreeDSAuthenticationChallengeParams
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ThreeDSAuthenticationChallengeParams
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestThreeDSAuthenticationChallengeParams_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"creq\":\"eyJtZXNzYWdlVHlwZSI6IkNSZXEiLCJtZXNzYWdlVmVyc2lvbiI6IjIuMS4wIiwidGhyZWVEU1NlcnZlclRyYW5zSUQiOiIyNzljZjUwYy1lZjM2LTQzMTMtYjA0ZC05NGNlZGZhZWRmZDQiLCJhY3NUcmFuc0lEIjoiZDZmMTVhYWUtMmM5ZC00MzMzLWE5MjAtOTU0YmUwN2MwYzc2IiwiY2hhbGxlbmdlV2luZG93U2l6ZSI6IjA0In0=\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ThreeDSAuthenticationChallengeParams

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				var validateErr *validate.Error
				if errors.As(err, &validateErr) {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ThreeDSAuthenticationChallengeParams
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestThreeDSAuthenticationChallengeReq_EncodeDecode(t *testing.T) {
	var typ ThreeDSAuthenticationChallengeReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ThreeDSAuthenticationChallengeReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestThreeDSAuthenticationCreate_EncodeDecode(t *testing.T) {
	var typ ThreeDSAuthenticationCreate
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ThreeDSAuthenticationCreate
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestThreeDSAuthenticationData_EncodeDecode(t *testing.T) {
	var typ ThreeDSAuthenticationData
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ThreeDSAuthenticationData
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestThreeDSAuthenticationDeviceFingerprint_EncodeDecode(t *testing.T) {
	var typ ThreeDSAuthenticationDeviceFingerprint
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ThreeDSAuthenticationDeviceFingerprint
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestThreeDSAuthenticationDeviceFingerprintParams_EncodeDecode(t *testing.T) {
	var typ ThreeDSAuthenticationDeviceFingerprintParams
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ThreeDSAuthenticationDeviceFingerprintParams
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestThreeDSAuthenticationDeviceFingerprintParams_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"threeDSMethodData\":\"3DS method data\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ThreeDSAuthenticationDeviceFingerprintParams

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				var validateErr *validate.Error
				if errors.As(err, &validateErr) {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ThreeDSAuthenticationDeviceFingerprintParams
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestThreeDSAuthenticationDeviceFingerprintReq_EncodeDecode(t *testing.T) {
	var typ ThreeDSAuthenticationDeviceFingerprintReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ThreeDSAuthenticationDeviceFingerprintReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestThreeDSAuthenticationState_EncodeDecode(t *testing.T) {
	var typ ThreeDSAuthenticationState
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ThreeDSAuthenticationState
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestThreeDSAuthenticationState_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "\"successful\""},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ThreeDSAuthenticationState

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				var validateErr *validate.Error
				if errors.As(err, &validateErr) {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ThreeDSAuthenticationState
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestThreeDSProvider_EncodeDecode(t *testing.T) {
	var typ ThreeDSProvider
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ThreeDSProvider
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestThreeDSProviderApiErrors_EncodeDecode(t *testing.T) {
	var typ ThreeDSProviderApiErrors
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ThreeDSProviderApiErrors
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestThreeDSProviderConfig_EncodeDecode(t *testing.T) {
	var typ ThreeDSProviderConfig
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ThreeDSProviderConfig
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestThreeDSProviderCreate_EncodeDecode(t *testing.T) {
	var typ ThreeDSProviderCreate
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ThreeDSProviderCreate
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestThreeDSProviderCreate_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"config\":{\"api_key\":\"2X/NqoasDDpfgOm7KnWNHA==\"},\"type\":\"paay\"}"},
		{Input: "{\"config\":{\"merchant_account\":\"BARBAR\",\"password\":\"foo\",\"username\":\"username\"},\"type\":\"adyen\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ThreeDSProviderCreate

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				var validateErr *validate.Error
				if errors.As(err, &validateErr) {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ThreeDSProviderCreate
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestThreeDSProviderCreateConfig_EncodeDecode(t *testing.T) {
	var typ ThreeDSProviderCreateConfig
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ThreeDSProviderCreateConfig
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestThreeDSProviderData_EncodeDecode(t *testing.T) {
	var typ ThreeDSProviderData
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ThreeDSProviderData
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestThreeDSProviderType_EncodeDecode(t *testing.T) {
	var typ ThreeDSProviderType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ThreeDSProviderType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTransfer_EncodeDecode(t *testing.T) {
	var typ Transfer
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Transfer
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTransferCapture_EncodeDecode(t *testing.T) {
	var typ TransferCapture
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TransferCapture
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTransferCreate_EncodeDecode(t *testing.T) {
	var typ TransferCreate
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TransferCreate
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTransferData_EncodeDecode(t *testing.T) {
	var typ TransferData
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TransferData
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTransferGatewayResponse_EncodeDecode(t *testing.T) {
	var typ TransferGatewayResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TransferGatewayResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTransferGatewayResponseState_EncodeDecode(t *testing.T) {
	var typ TransferGatewayResponseState
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TransferGatewayResponseState
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTransferListData_EncodeDecode(t *testing.T) {
	var typ TransferListData
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TransferListData
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTransferListDataLinks_EncodeDecode(t *testing.T) {
	var typ TransferListDataLinks
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TransferListDataLinks
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTransferListDataMeta_EncodeDecode(t *testing.T) {
	var typ TransferListDataMeta
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TransferListDataMeta
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTransferState_EncodeDecode(t *testing.T) {
	var typ TransferState
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TransferState
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestTransferState_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "\"successful\""},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ TransferState

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				var validateErr *validate.Error
				if errors.As(err, &validateErr) {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 TransferState
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestTransferType_EncodeDecode(t *testing.T) {
	var typ TransferType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TransferType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTransferUpdate_EncodeDecode(t *testing.T) {
	var typ TransferUpdate
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TransferUpdate
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestTransferUpdate_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"action\":\"cancel\"}"},
		{Input: "{\"action\":\"capture\",\"amount\":100}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ TransferUpdate

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				var validateErr *validate.Error
				if errors.As(err, &validateErr) {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 TransferUpdate
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestTransferUpdateAction_EncodeDecode(t *testing.T) {
	var typ TransferUpdateAction
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TransferUpdateAction
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestTransferUpdateAction_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "\"capture\""},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ TransferUpdateAction

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				var validateErr *validate.Error
				if errors.As(err, &validateErr) {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 TransferUpdateAction
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestTransfersApiErrors_EncodeDecode(t *testing.T) {
	var typ TransfersApiErrors
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TransfersApiErrors
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestVerification_EncodeDecode(t *testing.T) {
	var typ Verification
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Verification
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestVerificationData_EncodeDecode(t *testing.T) {
	var typ VerificationData
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 VerificationData
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestVerificationTransfer_EncodeDecode(t *testing.T) {
	var typ VerificationTransfer
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 VerificationTransfer
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestVerificationTransferState_EncodeDecode(t *testing.T) {
	var typ VerificationTransferState
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 VerificationTransferState
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestVerificationTransferState_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "\"successful\""},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ VerificationTransferState

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				var validateErr *validate.Error
				if errors.As(err, &validateErr) {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 VerificationTransferState
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestVerificationTransferType_EncodeDecode(t *testing.T) {
	var typ VerificationTransferType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 VerificationTransferType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
