// Package vault provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.10.1 DO NOT EDIT.
package vault

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
)

const (
	BasicAuthScopes = "basicAuth.Scopes"
)

// Defines values for AliasFormat.
const (
	AliasFormatFPEACCNUMTFOUR AliasFormat = "FPE_ACC_NUM_T_FOUR"

	AliasFormatFPEALPHANUMERICACCNUMTFOUR AliasFormat = "FPE_ALPHANUMERIC_ACC_NUM_T_FOUR"

	AliasFormatFPESIXTFOUR AliasFormat = "FPE_SIX_T_FOUR"

	AliasFormatFPESSNTFOUR AliasFormat = "FPE_SSN_T_FOUR"

	AliasFormatFPETFOUR AliasFormat = "FPE_T_FOUR"

	AliasFormatNUMLENGTHPRESERVING AliasFormat = "NUM_LENGTH_PRESERVING"

	AliasFormatPFPT AliasFormat = "PFPT"

	AliasFormatRAWUUID AliasFormat = "RAW_UUID"

	AliasFormatUUID AliasFormat = "UUID"
)

// Defines values for RevealedDataStorage.
const (
	RevealedDataStoragePERSISTENT RevealedDataStorage = "PERSISTENT"

	RevealedDataStorageVOLATILE RevealedDataStorage = "VOLATILE"
)

// Alias defines model for Alias.
type Alias struct {
	// Opaque string used to substitute the raw value.
	Alias *string `json:"alias,omitempty"`

	// Format of the generated alias string.
	//
	// See [Alias Formats](#section/Introduction/Alias-Formats) for details.
	Format *AliasFormat `json:"format,omitempty"`
}

// Format of the generated alias string.
//
// See [Alias Formats](#section/Introduction/Alias-Formats) for details.
type AliasFormat string

// ApiError defines model for ApiError.
type ApiError struct {
	// Explanation of what exactly went wrong.
	Detail *string `json:"detail,omitempty"`

	// Request URL.
	Href *string `json:"href,omitempty"`

	// HTTP status code.
	Status *int `json:"status,omitempty"`

	// High-level reason of why the request failed.
	Title *string `json:"title,omitempty"`
}

// CreateAliasesRequest defines model for CreateAliasesRequest.
type CreateAliasesRequest struct {
	Data []interface{} `json:"data"`
}

// RevealedData defines model for RevealedData.
type RevealedData struct {
	// List of aliases associated with the value.
	Aliases *[]Alias `json:"aliases,omitempty"`

	// List of tags the value is classified with.
	Classifiers *[]string `json:"classifiers,omitempty"`

	// Creation time, in UTC.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Storage medium to use.
	//
	// VOLATILE results in data being persisted into an in-memory data store for one hour which is required for PCI compliant storage of card security code data.
	Storage *RevealedDataStorage `json:"storage,omitempty"`

	// Decrypted value stored in the vault.
	Value *string `json:"value,omitempty"`
}

// Storage medium to use.
//
// VOLATILE results in data being persisted into an in-memory data store for one hour which is required for PCI compliant storage of card security code data.
type RevealedDataStorage string

// UpdateAliasRequest defines model for UpdateAliasRequest.
type UpdateAliasRequest struct {
	Data struct {
		// List of tags to classify the value with.
		Classifiers []string `json:"classifiers"`
	} `json:"data"`
}

// ApiErrorsResponse defines model for ApiErrorsResponse.
type ApiErrorsResponse struct {
	// List of errors that occurred while processing the request.
	Errors *[]ApiError `json:"errors,omitempty"`
}

// RevealMultipleAliasesParams defines parameters for RevealMultipleAliases.
type RevealMultipleAliasesParams struct {
	// Comma-separated list of aliases to reveal.
	Q string `json:"q"`
}

// CreateAliasesJSONBody defines parameters for CreateAliases.
type CreateAliasesJSONBody CreateAliasesRequest

// UpdateAliasJSONBody defines parameters for UpdateAlias.
type UpdateAliasJSONBody UpdateAliasRequest

// CreateAliasesJSONRequestBody defines body for CreateAliases for application/json ContentType.
type CreateAliasesJSONRequestBody CreateAliasesJSONBody

// UpdateAliasJSONRequestBody defines body for UpdateAlias for application/json ContentType.
type UpdateAliasJSONRequestBody UpdateAliasJSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// RevealMultipleAliases request
	RevealMultipleAliases(ctx context.Context, params *RevealMultipleAliasesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAliases request with any body
	CreateAliasesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAliases(ctx context.Context, body CreateAliasesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAlias request
	DeleteAlias(ctx context.Context, alias string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RevealAlias request
	RevealAlias(ctx context.Context, alias string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAlias request with any body
	UpdateAliasWithBody(ctx context.Context, alias string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAlias(ctx context.Context, alias string, body UpdateAliasJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) RevealMultipleAliases(ctx context.Context, params *RevealMultipleAliasesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevealMultipleAliasesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAliasesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAliasesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAliases(ctx context.Context, body CreateAliasesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAliasesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAlias(ctx context.Context, alias string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAliasRequest(c.Server, alias)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevealAlias(ctx context.Context, alias string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevealAliasRequest(c.Server, alias)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAliasWithBody(ctx context.Context, alias string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAliasRequestWithBody(c.Server, alias, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAlias(ctx context.Context, alias string, body UpdateAliasJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAliasRequest(c.Server, alias, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewRevealMultipleAliasesRequest generates requests for RevealMultipleAliases
func NewRevealMultipleAliasesRequest(server string, params *RevealMultipleAliasesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/aliases")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, params.Q); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAliasesRequest calls the generic CreateAliases builder with application/json body
func NewCreateAliasesRequest(server string, body CreateAliasesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAliasesRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateAliasesRequestWithBody generates requests for CreateAliases with any type of body
func NewCreateAliasesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/aliases")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAliasRequest generates requests for DeleteAlias
func NewDeleteAliasRequest(server string, alias string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "alias", runtime.ParamLocationPath, alias)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/aliases/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRevealAliasRequest generates requests for RevealAlias
func NewRevealAliasRequest(server string, alias string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "alias", runtime.ParamLocationPath, alias)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/aliases/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateAliasRequest calls the generic UpdateAlias builder with application/json body
func NewUpdateAliasRequest(server string, alias string, body UpdateAliasJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAliasRequestWithBody(server, alias, "application/json", bodyReader)
}

// NewUpdateAliasRequestWithBody generates requests for UpdateAlias with any type of body
func NewUpdateAliasRequestWithBody(server string, alias string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "alias", runtime.ParamLocationPath, alias)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/aliases/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// RevealMultipleAliases request
	RevealMultipleAliasesWithResponse(ctx context.Context, params *RevealMultipleAliasesParams, reqEditors ...RequestEditorFn) (*RevealMultipleAliasesResponse, error)

	// CreateAliases request with any body
	CreateAliasesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAliasesResponse, error)

	CreateAliasesWithResponse(ctx context.Context, body CreateAliasesJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAliasesResponse, error)

	// DeleteAlias request
	DeleteAliasWithResponse(ctx context.Context, alias string, reqEditors ...RequestEditorFn) (*DeleteAliasResponse, error)

	// RevealAlias request
	RevealAliasWithResponse(ctx context.Context, alias string, reqEditors ...RequestEditorFn) (*RevealAliasResponse, error)

	// UpdateAlias request with any body
	UpdateAliasWithBodyWithResponse(ctx context.Context, alias string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAliasResponse, error)

	UpdateAliasWithResponse(ctx context.Context, alias string, body UpdateAliasJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAliasResponse, error)
}

type RevealMultipleAliasesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *interface{} `json:"data,omitempty"`
	}
	JSONDefault *struct {
		// List of errors that occurred while processing the request.
		Errors *[]ApiError `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r RevealMultipleAliasesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RevealMultipleAliasesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAliasesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// List of stored values along with their aliases.
		Data *[]RevealedData `json:"data,omitempty"`
	}
	JSONDefault *struct {
		// List of errors that occurred while processing the request.
		Errors *[]ApiError `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateAliasesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAliasesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAliasResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *struct {
		// List of errors that occurred while processing the request.
		Errors *[]ApiError `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteAliasResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAliasResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RevealAliasResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RevealedData
	JSONDefault  *struct {
		// List of errors that occurred while processing the request.
		Errors *[]ApiError `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r RevealAliasResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RevealAliasResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAliasResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *struct {
		// List of errors that occurred while processing the request.
		Errors *[]ApiError `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdateAliasResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAliasResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// RevealMultipleAliasesWithResponse request returning *RevealMultipleAliasesResponse
func (c *ClientWithResponses) RevealMultipleAliasesWithResponse(ctx context.Context, params *RevealMultipleAliasesParams, reqEditors ...RequestEditorFn) (*RevealMultipleAliasesResponse, error) {
	rsp, err := c.RevealMultipleAliases(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevealMultipleAliasesResponse(rsp)
}

// CreateAliasesWithBodyWithResponse request with arbitrary body returning *CreateAliasesResponse
func (c *ClientWithResponses) CreateAliasesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAliasesResponse, error) {
	rsp, err := c.CreateAliasesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAliasesResponse(rsp)
}

func (c *ClientWithResponses) CreateAliasesWithResponse(ctx context.Context, body CreateAliasesJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAliasesResponse, error) {
	rsp, err := c.CreateAliases(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAliasesResponse(rsp)
}

// DeleteAliasWithResponse request returning *DeleteAliasResponse
func (c *ClientWithResponses) DeleteAliasWithResponse(ctx context.Context, alias string, reqEditors ...RequestEditorFn) (*DeleteAliasResponse, error) {
	rsp, err := c.DeleteAlias(ctx, alias, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAliasResponse(rsp)
}

// RevealAliasWithResponse request returning *RevealAliasResponse
func (c *ClientWithResponses) RevealAliasWithResponse(ctx context.Context, alias string, reqEditors ...RequestEditorFn) (*RevealAliasResponse, error) {
	rsp, err := c.RevealAlias(ctx, alias, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevealAliasResponse(rsp)
}

// UpdateAliasWithBodyWithResponse request with arbitrary body returning *UpdateAliasResponse
func (c *ClientWithResponses) UpdateAliasWithBodyWithResponse(ctx context.Context, alias string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAliasResponse, error) {
	rsp, err := c.UpdateAliasWithBody(ctx, alias, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAliasResponse(rsp)
}

func (c *ClientWithResponses) UpdateAliasWithResponse(ctx context.Context, alias string, body UpdateAliasJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAliasResponse, error) {
	rsp, err := c.UpdateAlias(ctx, alias, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAliasResponse(rsp)
}

// ParseRevealMultipleAliasesResponse parses an HTTP response from a RevealMultipleAliasesWithResponse call
func ParseRevealMultipleAliasesResponse(rsp *http.Response) (*RevealMultipleAliasesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RevealMultipleAliasesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *interface{} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// List of errors that occurred while processing the request.
			Errors *[]ApiError `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateAliasesResponse parses an HTTP response from a CreateAliasesWithResponse call
func ParseCreateAliasesResponse(rsp *http.Response) (*CreateAliasesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAliasesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// List of stored values along with their aliases.
			Data *[]RevealedData `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// List of errors that occurred while processing the request.
			Errors *[]ApiError `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteAliasResponse parses an HTTP response from a DeleteAliasWithResponse call
func ParseDeleteAliasResponse(rsp *http.Response) (*DeleteAliasResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAliasResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// List of errors that occurred while processing the request.
			Errors *[]ApiError `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseRevealAliasResponse parses an HTTP response from a RevealAliasWithResponse call
func ParseRevealAliasResponse(rsp *http.Response) (*RevealAliasResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RevealAliasResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RevealedData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// List of errors that occurred while processing the request.
			Errors *[]ApiError `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateAliasResponse parses an HTTP response from a UpdateAliasWithResponse call
func ParseUpdateAliasResponse(rsp *http.Response) (*UpdateAliasResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAliasResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// List of errors that occurred while processing the request.
			Errors *[]ApiError `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Reveal multiple aliases
	// (GET /aliases)
	RevealMultipleAliases(w http.ResponseWriter, r *http.Request, params RevealMultipleAliasesParams)
	// Create aliases
	// (POST /aliases)
	CreateAliases(w http.ResponseWriter, r *http.Request)
	// Delete alias
	// (DELETE /aliases/{alias})
	DeleteAlias(w http.ResponseWriter, r *http.Request, alias string)
	// Reveal single alias
	// (GET /aliases/{alias})
	RevealAlias(w http.ResponseWriter, r *http.Request, alias string)
	// Update data classifiers
	// (PUT /aliases/{alias})
	UpdateAlias(w http.ResponseWriter, r *http.Request, alias string)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.HandlerFunc) http.HandlerFunc

// RevealMultipleAliases operation middleware
func (siw *ServerInterfaceWrapper) RevealMultipleAliases(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params RevealMultipleAliasesParams

	// ------------- Required query parameter "q" -------------
	if paramValue := r.URL.Query().Get("q"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "q"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "q", r.URL.Query(), &params.Q)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "q", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RevealMultipleAliases(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CreateAliases operation middleware
func (siw *ServerInterfaceWrapper) CreateAliases(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateAliases(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteAlias operation middleware
func (siw *ServerInterfaceWrapper) DeleteAlias(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "alias" -------------
	var alias string

	err = runtime.BindStyledParameter("simple", false, "alias", chi.URLParam(r, "alias"), &alias)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "alias", Err: err})
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteAlias(w, r, alias)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// RevealAlias operation middleware
func (siw *ServerInterfaceWrapper) RevealAlias(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "alias" -------------
	var alias string

	err = runtime.BindStyledParameter("simple", false, "alias", chi.URLParam(r, "alias"), &alias)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "alias", Err: err})
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RevealAlias(w, r, alias)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UpdateAlias operation middleware
func (siw *ServerInterfaceWrapper) UpdateAlias(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "alias" -------------
	var alias string

	err = runtime.BindStyledParameter("simple", false, "alias", chi.URLParam(r, "alias"), &alias)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "alias", Err: err})
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateAlias(w, r, alias)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/aliases", wrapper.RevealMultipleAliases)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/aliases", wrapper.CreateAliases)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/aliases/{alias}", wrapper.DeleteAlias)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/aliases/{alias}", wrapper.RevealAlias)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/aliases/{alias}", wrapper.UpdateAlias)
	})

	return r
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
